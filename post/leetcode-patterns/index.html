<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>Mastering Common Patterns to Solve Leetcode Problems |
Saikat Kumar Dey</title><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Saikat Kumar Dey"><meta name=description content="Machine Learning Engineer"><link rel=stylesheet href=/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=https://saikatkumardey.com/post/leetcode-patterns/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://saikatkumardey.com/images/site-feature-image.png"><meta name=twitter:title content="Mastering Common Patterns to Solve Leetcode Problems"><meta name=twitter:description content="Knowing these patterns can help you solve most of the problems in leetcode"><meta property="og:title" content="Mastering Common Patterns to Solve Leetcode Problems"><meta property="og:description" content="Knowing these patterns can help you solve most of the problems in leetcode"><meta property="og:type" content="article"><meta property="og:url" content="https://saikatkumardey.com/post/leetcode-patterns/"><meta property="og:image" content="https://saikatkumardey.com/images/site-feature-image.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-01T10:25:29+05:30"><meta property="article:modified_time" content="2022-12-01T10:25:29+05:30"><meta property="og:site_name" content="Saikat Kumar Dey"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Mastering Common Patterns to Solve Leetcode Problems","headline":"Mastering Common Patterns to Solve Leetcode Problems","alternativeHeadline":"","description":"
      
        Knowing these patterns can help you solve most of the problems in leetcode


      


    ","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/saikatkumardey.com\/post\/leetcode-patterns\/"},"author":{"@type":"Person","name":"Saikat Kumar Dey"},"creator":{"@type":"Person","name":"Saikat Kumar Dey"},"accountablePerson":{"@type":"Person","name":"Saikat Kumar Dey"},"copyrightHolder":{"@type":"Person","name":"Saikat Kumar Dey"},"copyrightYear":"2022","dateCreated":"2022-12-01T10:25:29.00Z","datePublished":"2022-12-01T10:25:29.00Z","dateModified":"2022-12-01T10:25:29.00Z","publisher":{"@type":"Organization","name":"Saikat Kumar Dey","url":"https://saikatkumardey.com","logo":{"@type":"ImageObject","url":"https:\/\/saikatkumardey.com\/favicons\/favicon-32x32.png","width":"32","height":"32"}},"image":["https://saikatkumardey.com/images/site-feature-image.png"],"url":"https:\/\/saikatkumardey.com\/post\/leetcode-patterns\/","wordCount":"5100","genre":["leetcode","coding"],"keywords":[]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/dp.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Saikat Kumar Dey</a></div><div class=sidebar__introduction-description><p>Machine Learning Engineer</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://linkedin.com/in/saikatkumardey target=_blank rel="noopener me" aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/saikatkumardey/ target=_blank rel="noopener me" aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.instagram.com/saikatkumardey/ target=_blank rel="noopener me" aria-label=instagram title=instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/saikatkrdey target=_blank rel="noopener me" aria-label=twitter title=twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Saikat Kumar Dey
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/projects/ title>Projects</a></li><li class=nav__list-item><a href=/now/ title>Now</a></li><li class=nav__list-item><a href=/contact/ title>Contact</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Mastering Common Patterns to Solve Leetcode Problems</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>1/12/2022</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>24-minute read</span></li></ul><p>In this post, I will introduce you to 14 important patterns that can help you solve most of the problems on Leetcode. I will provide a template for each pattern to help you quickly apply it to a problem, as well as a list of important problems to practice with. By the end of this post, you will have a powerful set of tools to enhance your problem-solving skills on Leetcode and beyond. Let&rsquo;s get started!</p><h2 id=1-sliding-window>1. Sliding Window</h2><p>The sliding window pattern is a common technique used to solve problems involving arrays or strings. It involves using a fixed-size &ldquo;window&rdquo; that slides through the array or string, and performs some operation on each sub-array or sub-string that it covers. This allows you to perform the operation on each possible sub-array or sub-string without having to create a new array or string for each one.</p><p>Here is a simple template in Python that you can use to solve any problem that uses the sliding window pattern:</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the window</span>
</span></span><span class=line><span class=cl><span class=n>window_start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>window_end</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize any other variables you need</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until the window_end reaches the end of the array/string</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>window_end</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current sub-array/sub-string</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>window_start</span><span class=p>:</span><span class=n>window_end</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># move the window to the right</span>
</span></span><span class=line><span class=cl>  <span class=n>window_start</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=n>window_end</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>To use this template, you just need to define the update_result() function, which should take in the current sub-array/sub-string and the current result, and return an updated result.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the sliding window pattern:</p><ul><li><a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/>Longest Substring Without Repeating Characters</a>: This problem involves finding the longest substring in a string that does not contain any repeating characters. The sliding window pattern can be used to efficiently search for this substring.</li><li><a href=https://leetcode.com/problems/minimum-size-subarray-sum/>Minimum Size Subarray Sum</a>: This problem involves finding the smallest subarray in an array that has a given sum. The sliding window pattern can be used to efficiently search for this subarray.</li><li><a href=https://leetcode.com/problems/permutation-in-string/>Permutation in String</a>: This problem involves checking whether one string is a permutation of another string. The sliding window pattern can be used to efficiently compare the two strings and check for a permutation.</li><li><a href=https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/>Longest Substring with At Most Two Distinct Characters</a> 💰: This problem involves finding the longest substring in a string that contains at most two distinct characters. The sliding window pattern can be used to efficiently search for this substring.</li><li><a href=https://leetcode.com/problems/minimum-window-substring/>Minimum Window Substring</a>: This problem involves finding the smallest substring in a string that contains all of the characters in another string. The sliding window pattern can be used to efficiently search for this substring.</li></ul><h2 id=2-two-pointers>2. Two pointers</h2><p>The two pointers pattern is a common technique used to solve problems involving arrays or strings. It involves using two &ldquo;pointers&rdquo; that point to different elements in the array or string, and moving them in a specific way to perform some operation on the sub-array or sub-string they cover. This allows you to perform the operation on each possible sub-array or sub-string without having to create a new array or string for each one.</p><p>Here is a simple template in Python that you can use to solve any problem that uses the two pointers pattern:</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the pointers</span>
</span></span><span class=line><span class=cl><span class=n>pointer1</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>pointer2</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize any other variables you need</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until the pointers reach the end of the array/string</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>pointer1</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=ow>and</span> <span class=n>pointer2</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current sub-array/sub-string</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>pointer1</span><span class=p>:</span><span class=n>pointer2</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># move the pointers according to the specific rules of the pattern</span>
</span></span><span class=line><span class=cl>  <span class=n>pointer1</span><span class=p>,</span> <span class=n>pointer2</span> <span class=o>=</span> <span class=n>move_pointers</span><span class=p>(</span><span class=n>pointer1</span><span class=p>,</span> <span class=n>pointer2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>To use this template, you just need to define the move_pointers() and update_result() functions. The move_pointers() function should take in the current values of the pointers, and return updated values for the pointers according to the specific rules of the pattern. The update_result() function should take in the current sub-array/sub-string and the current result, and return an updated result.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the two pointers pattern:</p><ul><li><a href=https://leetcode.com/problems/two-sum/>Two Sum</a>: This problem involves finding two numbers in an array that add up to a given target number. The two pointers pattern can be used to efficiently search for these numbers by moving the pointers in opposite directions.</li><li><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array/>Remove Duplicates from Sorted Array</a>: This problem involves removing duplicate elements from a sorted array. The two pointers pattern can be used to efficiently remove the duplicates by comparing the elements at each pointer and moving them as necessary.</li><li><a href=https://leetcode.com/problems/container-with-most-water/>Container With Most Water</a>: This problem involves finding the maximum area of a container formed by two lines on a graph. The two pointers pattern can be used to efficiently search for the maximum area by moving the pointers in opposite directions.</li><li><a href=https://leetcode.com/problems/trapping-rain-water/>Trapping Rain Water</a>: This problem involves finding the amount of rainwater that can be trapped between bars on a histogram. The two pointers pattern can be used to efficiently calculate the trapped water by moving the pointers inwards from the ends of the array.</li></ul><h2 id=3-fast-and-slow-pointers>3. Fast and slow pointers</h2><p>The fast and slow pointers pattern is a common technique used to solve problems involving linked lists. It involves using two pointers that traverse the linked list at different speeds. The &ldquo;slow&rdquo; pointer moves one step at a time, while the &ldquo;fast&rdquo; pointer moves two steps at a time. This allows the fast pointer to &ldquo;lap&rdquo; the slow pointer, and makes it possible to detect when the two pointers are pointing to the same node (i.e., they have &ldquo;collided&rdquo;).</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the pointers</span>
</span></span><span class=line><span class=cl><span class=n>slow_pointer</span> <span class=o>=</span> <span class=n>linked_list</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl><span class=n>fast_pointer</span> <span class=o>=</span> <span class=n>linked_list</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize any other variables you need</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until the pointers reach the end of the linked list</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>fast_pointer</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>fast_pointer</span><span class=o>.</span><span class=n>next</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current nodes</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>slow_pointer</span><span class=p>,</span> <span class=n>fast_pointer</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># move the pointers according to the specific rules of the pattern</span>
</span></span><span class=line><span class=cl>  <span class=n>slow_pointer</span> <span class=o>=</span> <span class=n>slow_pointer</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>  <span class=n>fast_pointer</span> <span class=o>=</span> <span class=n>fast_pointer</span><span class=o>.</span><span class=n>next</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># check if the pointers have collided</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>slow_pointer</span> <span class=o>==</span> <span class=n>fast_pointer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>To use this template, you just need to define the update_result() function, which should take in the current values of the slow and fast pointers, and the current result, and return an updated result.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the fast and slow pointers pattern:</p><ul><li><a href=https://leetcode.com/problems/linked-list-cycle/>Linked List Cycle</a>: This problem involves detecting whether a linked list contains a cycle. The fast and slow pointers pattern can be used to efficiently detect the cycle by moving the pointers at different speeds and checking for overlap.</li><li><a href=https://leetcode.com/problems/middle-of-the-linked-list/>Middle of the Linked List</a>: This problem involves finding the middle element of a linked list. The fast and slow pointers pattern can be used to efficiently find the middle element by moving the pointers at different speeds and stopping when the fast pointer reaches the end of the list.</li><li><a href=https://leetcode.com/problems/happy-number/>Happy Number</a>: This problem involves determining whether a number is a happy number. The fast and slow pointers pattern can be used to efficiently check for happiness by moving the pointers at different speeds and checking for a cycle.
Reorder List: This problem involves reordering the elements of a linked list in a specific way. The fast and slow pointers pattern can be used to efficiently reorder the elements by moving the pointers at different speeds and rearranging the elements as necessary.</li><li><a href=https://leetcode.com/problems/palindrome-linked-list/>Palindrome Linked List</a>: This problem involves checking whether a linked list is a palindrome. The fast and slow pointers pattern can be used to efficiently check for palindromicity by moving the pointers at different speeds and comparing the elements at each pointer.</li></ul><h2 id=4-merge-intervals>4. Merge Intervals</h2><p>The merge intervals pattern is a common technique used to solve problems involving sets of intervals. It involves sorting the intervals by their start time, and then merging any intervals that overlap. This allows you to take a set of potentially overlapping intervals and convert it into a set of non-overlapping intervals.</p><p>Here is a simple template in Python that you can use to solve any problem that uses the merge intervals pattern:</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># sort the intervals by their start time</span>
</span></span><span class=line><span class=cl><span class=n>intervals</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>intervals</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize the result list with the first interval</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[</span><span class=n>intervals</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop through the remaining intervals</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>intervals</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>  <span class=c1># get the last interval in the result list</span>
</span></span><span class=line><span class=cl>  <span class=n>last_interval</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># check if the current interval overlaps with the last interval</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>intervals</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>last_interval</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=c1># if it does, merge the current interval with the last interval</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>last_interval</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nb>max</span><span class=p>(</span><span class=n>last_interval</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>intervals</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># if it doesn&#39;t, add the current interval to the result list</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>intervals</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>To use this template, you just need to provide a list of intervals (in the form of tuples of start and end times), and the template will return a list of non-overlapping intervals.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the merge intervals pattern:</p><p>-<a href=https://leetcode.com/problems/merge-intervals>Merge Intervals</a>: This problem involves merging a list of intervals that may overlap.</p><ul><li><a href=https://leetcode.com/problems/insert-interval>Insert Interval</a>: This problem involves inserting a new interval into a list of intervals that may overlap.</li><li><a href=https://leetcode.com/problems/meeting-rooms>Meeting Rooms</a>: This problem involves checking whether it is possible to attend all of the meetings in a list of intervals.</li><li><a href=https://leetcode.com/problems/meeting-rooms-ii>Meeting Rooms II</a>: This problem involves finding the minimum number of rooms needed to hold all of the meetings in a list of intervals.</li><li><a href=https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons>Minimum Number of Arrows to Burst Balloons</a>: This problem involves finding the minimum number of arrows needed to burst a given set of balloons.</li></ul><h2 id=5-cyclic-sort>5. Cyclic sort</h2><p>Cyclic sort is a technique used to sort a list of numbers that are in a certain range, but not necessarily in the correct order. It involves looping through the list and &ldquo;cycling&rdquo; the numbers into the correct positions. For example, if the list is [3, 1, 5, 4, 2] and the range is 1 to 5, the first step would be to put the 1 in its correct position at index 0, the second step would be to put the 2 in its correct position at index 1, and so on.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the current index and the number of items to sort</span>
</span></span><span class=line><span class=cl><span class=n>current_index</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>num_to_sort</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until all items have been sorted</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>num_to_sort</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># get the correct value for the current index</span>
</span></span><span class=line><span class=cl>  <span class=n>correct_value</span> <span class=o>=</span> <span class=n>current_index</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># check if the current value is already correct</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>current_index</span><span class=p>]</span> <span class=o>==</span> <span class=n>correct_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># if it is, move on to the next index</span>
</span></span><span class=line><span class=cl>    <span class=n>current_index</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>num_to_sort</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># if it isn&#39;t, swap the current value with the correct value</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=n>current_index</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>arr</span><span class=p>[</span><span class=n>current_index</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>arr</span><span class=p>[</span><span class=n>current_index</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>current_index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the sorted array</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></div><p>To use this template, you just need to provide a list of numbers that are in a certain range, and the template will return the sorted list.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the cyclic sort pattern:</p><ul><li><a href=https://leetcode.com/problems/find-the-duplicate-number>Find the Duplicate Number</a>: This problem involves finding the duplicate element in an array of numbers that are in the range 1 to n.</li><li><a href=https://leetcode.com/problems/find-the-missing-number>Find the Missing Number</a>: This problem involves finding the missing element in an array of numbers that are in the range 1 to n.</li><li><a href=https://leetcode.com/problems/first-missing-positive/>First Missing Positive</a>: This problem involves finding the smallest missing positive number in an array of numbers.</li><li><a href=https://leetcode.com/problems/find-all-duplicates-in-an-array>Find All Duplicates in an Array</a>: This problem involves finding all of the duplicate elements in an array of numbers.</li></ul><h2 id=6-in-place-reversal-of-linked-list>6. In-place reversal of linked-list</h2><p>&ldquo;In-place reversal of a linked list&rdquo; refers to a technique for reversing the order of the nodes in a linked list without using any additional data structures. This is done by changing the links between the nodes in the linked list so that the nodes are connected in the opposite order.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the previous, current, and next nodes</span>
</span></span><span class=line><span class=cl><span class=n>prev_node</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=n>curr_node</span> <span class=o>=</span> <span class=n>linked_list</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl><span class=n>next_node</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until the current node is None</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>curr_node</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># store the next node</span>
</span></span><span class=line><span class=cl>  <span class=n>next_node</span> <span class=o>=</span> <span class=n>curr_node</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># reverse the link between the current and previous nodes</span>
</span></span><span class=line><span class=cl>  <span class=n>curr_node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>prev_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># move the previous and current nodes forward</span>
</span></span><span class=line><span class=cl>  <span class=n>prev_node</span> <span class=o>=</span> <span class=n>curr_node</span>
</span></span><span class=line><span class=cl>  <span class=n>curr_node</span> <span class=o>=</span> <span class=n>next_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># set the head of the linked list to the new start node</span>
</span></span><span class=line><span class=cl><span class=n>linked_list</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>prev_node</span>
</span></span></code></pre></div><p>To use this template, you just need to provide a linked list object and the template will reverse the order of the nodes in the linked list.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the in-place reversal of linked list pattern:</p><ul><li><a href=https://leetcode.com/problems/reverse-linked-list>Reverse Linked List</a>: This problem involves reversing the order of elements in a linked list.</li><li><a href=https://leetcode.com/problems/reverse-linked-list-ii>Reverse Linked List II</a>: This problem involves reversing a portion of a linked list.</li><li><a href=https://leetcode.com/problems/palindrome-linked-list>Palindrome Linked List</a>: This problem involves checking whether a linked list is a palindrome.</li><li><a href=https://leetcode.com/problems/reorder-list>Reorder List</a>: This problem involves reordering the elements of a linked list in a specific way.</li><li><a href=https://leetcode.com/problems/swap-nodes-in-pairs>Swap Nodes in Pairs</a>: This problem involves swapping the nodes in a linked list in pairs.</li></ul><h2 id=7-tree-bfs>7. Tree BFS</h2><p>The tree BFS (Breadth-First Search) pattern is a technique used to traverse the nodes of a tree in a level-by-level order. In the case of a binary tree (i.e., a tree in which each node has at most two children), the tree BFS algorithm can be implemented as follows:</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the queue with the root node</span>
</span></span><span class=line><span class=cl><span class=n>queue</span> <span class=o>=</span> <span class=p>[</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize any other variables you need</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until the queue is empty</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># get the next node from the queue</span>
</span></span><span class=line><span class=cl>  <span class=n>current_node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current node</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>current_node</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># add the left and right child nodes of the current node to the queue</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>current_node</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current_node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>current_node</span><span class=o>.</span><span class=n>right</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current_node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>To use this template, you just need to provide the root node of the binary tree and define the update_result() function, which should take in the current node and the current result, and return an updated result.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the tree BFS pattern:</p><ul><li><a href=https://leetcode.com/problems/binary-tree-level-order-traversal>Binary Tree Level Order Traversal</a>: This problem involves performing a level-order traversal of a binary tree.</li><li><a href=https://leetcode.com/problems/minimum-depth-of-binary-tree>Minimum Depth of Binary Tree</a>: This problem involves finding the minimum depth of a binary tree.</li><li><a href=https://leetcode.com/problems/symmetric-tree>Symmetric Tree</a>: This problem involves checking whether a binary tree is symmetric.</li><li><a href=https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal>Binary Tree Zigzag Level Order Traversal</a>: This problem involves performing a zigzag-level-order traversal of a binary tree.</li><li><a href=https://leetcode.com/problems/serialize-and-deserialize-binary-tree>Serialize and Deserialize Binary Tree</a>: This problem involves serializing and deserializing a binary tree.</li></ul><h2 id=8-tree-dfs>8. Tree DFS</h2><p>The tree DFS (Depth-First Search) pattern is a technique used to traverse the nodes of a tree in a depth-first manner. In the case of a binary tree (i.e., a tree in which each node has at most two children), the tree DFS algorithm can be implemented as follows:</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize any other variables you need</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># perform the DFS traversal on the root node</span>
</span></span><span class=line><span class=cl><span class=n>traverse</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>result</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current node</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># recursively traverse the left and right child nodes of the current node</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>traverse</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>traverse</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span></code></pre></div><p>To use this template, you just need to provide the root node of the binary tree and define the update_result() function, which should take in the current node and the current result, and return an updated result.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the tree DFS pattern:</p><ul><li><a href=https://leetcode.com/problems/binary-tree-preorder-traversal>Binary Tree Preorder Traversal</a>: This problem involves performing a preorder traversal of a binary tree.</li><li><a href=https://leetcode.com/problems/validate-binary-search-tree>Validate Binary Search Tree</a>: This problem involves checking whether a binary tree is a valid binary search tree.</li><li><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree>Maximum Depth of Binary Tree</a>: This problem involves finding the maximum depth of a binary tree.</li></ul><h2 id=9-two-heaps>9. Two heaps</h2><p>The &ldquo;two heaps&rdquo; pattern is a common technique used to solve problems involving sets of numbers. It involves using two heaps (i.e., data structures that provide efficient ways to insert and remove items, and to find the minimum or maximum item) to store the numbers in the set. This allows you to efficiently maintain certain properties of the numbers in the set, and to quickly perform operations on the numbers when needed.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize the two heaps</span>
</span></span><span class=line><span class=cl><span class=n>heap1</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>heap2</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># initialize any other variables you need</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop through the numbers in the set</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># insert the number into the appropriate heap</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>condition1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap1</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap2</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># balance the heaps if necessary</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>condition2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap2</span><span class=p>,</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>heap1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>condition3</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap1</span><span class=p>,</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>heap2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># update any other variables you need</span>
</span></span><span class=line><span class=cl>  <span class=n>update_variables</span><span class=p>(</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>To use this template, you just need to provide a list of numbers and define the condition1, condition2, condition3, and update_variables() functions. These functions should determine which heap to insert the current number into, whether the heaps need to be balanced, and how to update any other variables you need.</p><p>For example, if you want to use the two heaps pattern to find the median of a set of numbers, you could define the following functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># insert the number into the smaller_half heap if it is smaller than the current median,</span>
</span></span><span class=line><span class=cl><span class=c1># or into the larger_half heap if it is larger or equal to the current median</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>condition1</span><span class=p>(</span><span class=n>num</span><span class=p>,</span> <span class=n>median</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>num</span> <span class=o>&lt;</span> <span class=n>median</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># balance the heaps if the size difference between them is greater than 1</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>condition2</span><span class=p>(</span><span class=n>smaller_half</span><span class=p>,</span> <span class=n>larger_half</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>smaller_half</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>larger_half</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># balance the heaps if the size difference between them is greater than 1</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>condition3</span><span class=p>(</span><span class=n>smaller_half</span><span class=p>,</span> <span class=n>larger_half</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>larger_half</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>smaller_half</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># update the median if the size of the two heaps is equal, or if one heap is larger than the other</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>update_variables</span><span class=p>(</span><span class=n>num</span><span class=p>,</span> <span class=n>median</span><span class=p>,</span> <span class=n>smaller_half</span><span class=p>,</span> <span class=n>larger_half</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>smaller_half</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>larger_half</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>median</span> <span class=o>=</span> <span class=p>(</span><span class=o>-</span><span class=n>smaller_half</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>larger_half</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=nb>len</span><span class=p>(</span><span class=n>smaller_half</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>larger_half</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>median</span> <span class=o>=</span> <span class=o>-</span><span class=n>smaller_half</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>median</span> <span class=o>=</span> <span class=n>larger_half</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></div><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the two heaps pattern:</p><ul><li><a href=https://leetcode.com/problems/kth-largest-element-in-an-array>Kth Largest Element in an Array</a>: This problem involves finding the kth largest element in an array.</li><li><a href=https://leetcode.com/problems/median-of-two-sorted-arrays>Median of Two Sorted Arrays</a>: This problem involves finding the median of two sorted arrays.</li><li><a href=https://leetcode.com/problems/sliding-window-median>Sliding Window Median</a>: This problem involves finding the median of the elements in a sliding window of an array.</li><li><a href=https://leetcode.com/problems/top-k-frequent-elements>Top K Frequent Elements</a>: This problem involves finding the k most frequent elements in an array.</li><li><a href=https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix>Kth Smallest Element in a Sorted Matrix</a>: This problem involves finding the kth smallest element in a sorted matrix.</li></ul><h2 id=10-subsets>10. Subsets</h2><p>The &ldquo;subsets&rdquo; pattern is a common technique used to solve problems involving sets of numbers. It involves generating all possible subsets of the set and then performing some operation on each subset to find the desired result. This allows you to consider all possible combinations of numbers in the set and to efficiently compute the result for each combination.</p><p><strong>Template 1</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the result</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generate all possible subsets of the set</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>subset</span> <span class=ow>in</span> <span class=n>itertools</span><span class=o>.</span><span class=n>combinations</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>r</span><span class=p>)</span> <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current subset</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>subset</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p><strong>Template 2</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the result</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generate all possible subsets of the set</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=o>**</span><span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>  <span class=c1># convert the binary representation of i to a list of indices</span>
</span></span><span class=line><span class=cl>  <span class=n>indices</span> <span class=o>=</span> <span class=p>[</span><span class=n>j</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>))</span> <span class=k>if</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># generate the current subset</span>
</span></span><span class=line><span class=cl>  <span class=n>subset</span> <span class=o>=</span> <span class=p>[</span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>indices</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># perform the operation on the current subset</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=n>update_result</span><span class=p>(</span><span class=n>subset</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>It uses a single loop and binary operations to generate the subsets. It converts the binary representation of each number in the range 1..2^len(nums) to a list of indices, and then uses those indices to select the elements of the set that are included in the current subset.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the subsets pattern:</p><ul><li><a href=https://leetcode.com/problems/subsets>Subsets</a>: This problem involves generating all of the subsets of a given set of elements.</li><li><a href=https://leetcode.com/problems/subsets-ii>Subsets II</a>: This problem involves generating all of the subsets of a given set of elements, allowing for duplicates.</li><li><a href=https://leetcode.com/problems/permutations>Permutations</a>: This problem involves generating all of the permutations of a given set of elements.</li><li><a href=https://leetcode.com/problems/permutations-ii>Permutations II</a>: This problem involves generating all of the permutations of a given set of elements, allowing for duplicates.</li><li><a href=https://leetcode.com/problems/combination-sum>Combination Sum</a>: This problem involves finding all of the combinations of a given set of elements that add up to a specific target sum.</li></ul><h2 id=11-modified-binary-search>11. Modified Binary Search</h2><p>The &ldquo;modified binary search&rdquo; pattern is a common technique used to solve problems involving a sorted array of numbers. It is similar to regular binary search, but it allows you to modify the condition used to determine whether to search the left or right half of the array. This can be useful if the problem you&rsquo;re trying to solve involves finding the position of an element in the array that satisfies a certain condition, or if the array has duplicate elements and you need to find the first or last occurrence of a given element.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the left and right pointers</span>
</span></span><span class=line><span class=cl><span class=n>left</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>right</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># search the array until the left and right pointers meet</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># calculate the middle index</span>
</span></span><span class=line><span class=cl>  <span class=n>mid</span> <span class=o>=</span> <span class=n>left</span> <span class=o>+</span> <span class=p>(</span><span class=n>right</span> <span class=o>-</span> <span class=n>left</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># modify the condition used to determine which half of the array to search</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>condition</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>left</span>
</span></span></code></pre></div><p>If you want to use the modified binary search pattern to find the first occurrence of a given element in an array, you could define the following condition() function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>condition</span><span class=p>(</span><span class=n>num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>num</span> <span class=o>==</span> <span class=n>target</span> <span class=ow>and</span> <span class=p>(</span><span class=n>mid</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=n>target</span><span class=p>)</span>
</span></span></code></pre></div><p>This function checks whether the current element is equal to the target element and whether it is the first occurrence of that element in the array (i.e., whether the element before it is not equal to the target). If both of these conditions are satisfied, then the function returns True, indicating that the left pointer should be updated to the current index. Otherwise, it returns False, indicating that the right pointer should be updated to the current index.</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the modified binary search pattern:</p><ul><li><a href=https://leetcode.com/problems/search-in-rotated-sorted-array>Search in Rotated Sorted Array</a>: This problem involves searching for an element in a rotated sorted array.</li><li><a href=https://leetcode.com/problems/find-minimum-in-rotated-sorted-array>Find Minimum in Rotated Sorted Array</a>: This problem involves finding the minimum element in a rotated sorted array.</li><li><a href=https://leetcode.com/problems/search-in-rotated-sorted-array-ii>Search in Rotated Sorted Array II</a>: This problem involves searching for an element in a rotated sorted array that may contain duplicates.</li><li><a href=https://leetcode.com/problems/find-peak-element>Find Peak Element</a>: This problem involves finding a peak element in an array.</li><li><a href=https://leetcode.com/problems/find-k-closest-elements>Find K Closest Elements</a>: This problem involves finding the k closest elements to a given target in an array.</li></ul><h2 id=12-top-k-elements>12. Top K elements</h2><p>The &ldquo;top k elements&rdquo; pattern is a common technique used to solve problems involving a large set of numbers. It involves finding the largest or smallest k elements in the set and then performing some operation on those elements to find the desired result. This allows you to efficiently select the most important elements from the set and to compute the result using only those elements.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the heap with the first k elements of the set</span>
</span></span><span class=line><span class=cl><span class=n>heap</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[:</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># heapify the heap</span>
</span></span><span class=line><span class=cl><span class=n>heapq</span><span class=o>.</span><span class=n>heapify</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop through the remaining elements of the set</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>[</span><span class=n>k</span><span class=p>:]:</span>
</span></span><span class=line><span class=cl>  <span class=c1># insert the current element into the heap if it is larger than the smallest element in the heap</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>num</span> <span class=o>&gt;</span> <span class=n>heap</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappushpop</span><span class=p>(</span><span class=n>heap</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>operation</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span></code></pre></div><p>For example, if you want to use the top k elements pattern to find the sum of the largest k elements in a set, you could define the following operation() function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>operation</span><span class=p>(</span><span class=n>heap</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span></code></pre></div><p>This function simply returns the sum of all the elements in the heap, which are the largest k elements in the set</p><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the top k elements pattern:</p><ul><li><a href=https://leetcode.com/problems/kth-largest-element-in-an-array>Kth Largest Element in an Array</a>: This problem involves finding the kth largest element in an array.</li><li><a href=https://leetcode.com/problems/top-k-frequent-elements>Top K Frequent Elements</a>: This problem involves finding the k most frequent elements in an array.</li><li><a href=https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix>Kth Smallest Element in a Sorted Matrix</a>: This problem involves finding the kth smallest element in a sorted matrix.</li><li><a href=https://leetcode.com/problems/sort-colors>Sort Colors</a>: This problem involves sorting an array of colors (represented as numbers) in place.</li><li><a href=https://leetcode.com/problems/minimum-cost-to-hire-k-workers>Minimum Cost to Hire K Workers</a>: This problem involves finding the minimum cost to hire k workers, given their wage and productivity.</li></ul><h2 id=13-k-way-merge-using-heap>13. K-way Merge (using heap)</h2><p>The k-way merge pattern using a heap is a common technique used to merge k sorted arrays into a single sorted array. It involves using a heap data structure to efficiently select the smallest element from the k arrays and to add it to the result. This allows you to efficiently combine the k arrays into a single sorted array and to perform further operations on that array.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># initialize the result and the heap with the first elements of the k arrays</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>heap</span> <span class=o>=</span> <span class=p>[(</span><span class=n>arrays</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># heapify the heap</span>
</span></span><span class=line><span class=cl><span class=n>heapq</span><span class=o>.</span><span class=n>heapify</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loop until all the arrays have been merged</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>heap</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1># get the smallest element from the heap</span>
</span></span><span class=line><span class=cl>  <span class=n>min_element</span><span class=p>,</span> <span class=n>min_index</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># add the smallest element to the result</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>min_element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># insert the next element from the array where the smallest element was found into the heap</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>min_index</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>arrays</span><span class=p>[</span><span class=n>min_index</span><span class=p>])</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap</span><span class=p>,</span> <span class=p>(</span><span class=n>arrays</span><span class=p>[</span><span class=n>min_index</span><span class=p>][</span><span class=n>min_index</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>min_index</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># return the final result</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the k-way merge (using heap) pattern:</p><ul><li><a href=https://leetcode.com/problems/merge-k-sorted-lists>Merge k Sorted Lists</a>: This problem involves merging k sorted linked lists into a single sorted linked list.</li><li><a href=https://leetcode.com/problems/the-skyline-problem>The Skyline Problem</a>: This problem involves finding the skyline of a set of buildings.</li><li><a href=https://leetcode.com/problems/minimum-cost-to-connect-sticks>Minimum Cost to Connect Sticks</a>: This problem involves connecting a set of sticks with minimum total cost.</li><li><a href=https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended>Maximum Number of Events That Can Be Attended</a>: This problem involves finding the maximum number of events that a person can attend, given a list of events with start and end times.</li></ul><h2 id=14-topological-sort>14. Topological Sort</h2><p>Topological sort is an algorithm that is used to arrange the vertices of a directed acyclic graph (DAG) in a linear order such that, for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. This is useful for problems where a certain set of dependencies must be satisfied, such as scheduling tasks or determining the order in which to assemble a product.</p><p>To perform a topological sort, we first identify all of the vertices with no incoming edges (i.e., no dependencies) and put them in a queue. We then remove these vertices from the graph and repeat the process until the queue is empty. At each step, we add the vertices we remove to a list, which will eventually give us the topological ordering of the vertices.</p><p>Topological sort is commonly used to solve problems on LeetCode, such as &ldquo;Course Schedule&rdquo; and &ldquo;Alien Dictionary&rdquo;. It can also be useful for solving other problems that involve dependencies between objects or tasks.</p><p><strong>Template</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>topological_sort</span><span class=p>(</span><span class=n>vertices</span><span class=p>,</span> <span class=n>edges</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Create a list to store the topological ordering of the vertices</span>
</span></span><span class=line><span class=cl>    <span class=n>top_order</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Create a queue to keep track of the vertices with no incoming edges</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Create a dictionary to store the indegrees of each vertex</span>
</span></span><span class=line><span class=cl>    <span class=n>indegrees</span> <span class=o>=</span> <span class=p>{</span><span class=n>vertex</span><span class=p>:</span> <span class=mi>0</span> <span class=k>for</span> <span class=n>vertex</span> <span class=ow>in</span> <span class=n>vertices</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Create a dictionary to store the adjacency list for each vertex</span>
</span></span><span class=line><span class=cl>    <span class=n>adj_list</span> <span class=o>=</span> <span class=p>{</span><span class=n>vertex</span><span class=p>:</span> <span class=p>[]</span> <span class=k>for</span> <span class=n>vertex</span> <span class=ow>in</span> <span class=n>vertices</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Populate the indegrees dictionary and adjacency list</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=o>=</span> <span class=n>edge</span>
</span></span><span class=line><span class=cl>        <span class=n>indegrees</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>adj_list</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Add all vertices with no incoming edges to the queue</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>vertex</span><span class=p>,</span> <span class=n>indegree</span> <span class=ow>in</span> <span class=n>indegrees</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>indegree</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Perform the topological sort</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Remove a vertex from the queue</span>
</span></span><span class=line><span class=cl>        <span class=n>vertex</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Add the vertex to the topological ordering</span>
</span></span><span class=line><span class=cl>        <span class=n>top_order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Decrement the indegree of each of its neighbors</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>adj_list</span><span class=p>[</span><span class=n>vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>indegrees</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># If the indegree of a neighbor becomes 0, add it to the queue</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>indegrees</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># If there are any vertices left in the graph, then the original graph was not a DAG</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>top_order</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>top_order</span>
</span></span></code></pre></div><p><strong>Practise</strong></p><p>Here are some important problems on leetcode that can be solved using the topological sort pattern:</p><ul><li><a href=https://leetcode.com/problems/course-schedule>Course Schedule</a>: This problem involves checking whether a given set of courses can be completed, given the dependencies between the courses.</li><li><a href=https://leetcode.com/problems/course-schedule-ii>Course Schedule II</a>: This problem involves finding the order in which the courses should be taken in order to complete them all.</li><li><a href=https://leetcode.com/problems/alien-dictionary>Alien Dictionary</a>: This problem involves reconstructing the order of the letters in an alien language, given a list of words.</li><li><a href=https://leetcode.com/problems/sequence-reconstruction>Sequence Reconstruction</a>: This problem involves checking whether a given sequence can be reconstructed from a given set of subsequences.</li><li><a href=https://leetcode.com/problems/minimum-height-trees>Minimum Height Trees</a>: This problem involves finding the root(s) of a tree with minimum height.</li></ul><h1 id=references>References</h1><ul><li><p><a href="https://designgurus.org/link/pvL2Ws?url=https%3A%2F%2Fdesigngurus.org%2Fcourse%3Fcourseid%3Dgrokking-the-coding-interview">Grokking the Coding Interview: Patterns for Coding Questions</a></p><p>This is structured course for understanding every pattern step by step using visual walk-through.</p><p><em><strong>Disclaimer</strong>: It&rsquo;s an affiliate link. If you would like to thank me for this post, please purchase via that link. If you do not want to use that link for some reason, <a href=https://designgurus.org/course/grokking-the-coding-interview>here</a> is a clean link.</em> :)</p></li><li><p><a href=https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed>14 patterns to ace any coding interview question</a></p><p>This blog post is a fork of this post. I would recommend checking it out.
It&rsquo;s an overview of the <a href="https://designgurus.org/link/pvL2Ws?url=https%3A%2F%2Fdesigngurus.org%2Fcourse%3Fcourseid%3Dgrokking-the-coding-interview">Grokking course</a> shared above.</p></li><li><p><a href=https://emre.me/categories/#coding-patterns>emre.me #coding patterns</a></p><p>Excellent post about how to identify the patterns. Highly recommended.</p></li></ul></div><div class=post__footer><span><a class=category href=/categories/leetcode/>leetcode</a><a class=category href=/categories/coding/>coding</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Saikat Kumar Dey
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>