<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on Saikat Kumar Dey</title><link>https://saikatkumardey.com/categories/leetcode/</link><description>leetcode</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 01 Dec 2022 10:25:29 +0530</lastBuildDate><atom:link href="https://saikatkumardey.com/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode Patterns</title><link>https://saikatkumardey.com/posts/leetcode-patterns/</link><pubDate>Thu, 01 Dec 2022 10:25:29 +0530</pubDate><guid>https://saikatkumardey.com/posts/leetcode-patterns/</guid><description>&lt;h2 id="1-sliding-window">1. Sliding Window&lt;/h2>
&lt;p>The sliding window pattern is a common technique used to solve problems involving arrays or strings. It involves using a fixed-size &amp;ldquo;window&amp;rdquo; that slides through the array or string, and performs some operation on each sub-array or sub-string that it covers. This allows you to perform the operation on each possible sub-array or sub-string without having to create a new array or string for each one.&lt;/p>
&lt;p>Here is a simple template in Python that you can use to solve any problem that uses the sliding window pattern:&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the window&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">window_start&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">window_end&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until the window_end reaches the end of the array/string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">window_end&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">arr&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current sub-array/sub-string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">window_start&lt;/span>:&lt;span style="color:#000">window_end&lt;/span>&lt;span style="color:#000">+&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>], &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># move the window to the right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">window_start&lt;/span> &lt;span style="color:#000">+=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">window_end&lt;/span> &lt;span style="color:#000">+=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to define the update_result() function, which should take in the current sub-array/sub-string and the current result, and return an updated result.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the sliding window pattern:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters&lt;/a>: This problem involves finding the longest substring in a string that does not contain any repeating characters. The sliding window pattern can be used to efficiently search for this substring.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/minimum-size-subarray-sum/">Minimum Size Subarray Sum&lt;/a>: This problem involves finding the smallest subarray in an array that has a given sum. The sliding window pattern can be used to efficiently search for this subarray.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/permutation-in-string/">Permutation in String&lt;/a>: This problem involves checking whether one string is a permutation of another string. The sliding window pattern can be used to efficiently compare the two strings and check for a permutation.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/">Longest Substring with At Most Two Distinct Characters&lt;/a> ðŸ’°: This problem involves finding the longest substring in a string that contains at most two distinct characters. The sliding window pattern can be used to efficiently search for this substring.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/minimum-window-substring/">Minimum Window Substring&lt;/a>: This problem involves finding the smallest substring in a string that contains all of the characters in another string. The sliding window pattern can be used to efficiently search for this substring.&lt;/li>
&lt;/ul>
&lt;h2 id="2-two-pointers">2. Two pointers&lt;/h2>
&lt;p>The two pointers pattern is a common technique used to solve problems involving arrays or strings. It involves using two &amp;ldquo;pointers&amp;rdquo; that point to different elements in the array or string, and moving them in a specific way to perform some operation on the sub-array or sub-string they cover. This allows you to perform the operation on each possible sub-array or sub-string without having to create a new array or string for each one.&lt;/p>
&lt;p>Here is a simple template in Python that you can use to solve any problem that uses the two pointers pattern:&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the pointers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">pointer1&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">pointer2&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until the pointers reach the end of the array/string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">pointer1&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">arr&lt;/span>) &lt;span style="color:#000">and&lt;/span> &lt;span style="color:#000">pointer2&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">arr&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current sub-array/sub-string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">pointer1&lt;/span>:&lt;span style="color:#000">pointer2&lt;/span>&lt;span style="color:#000">+&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>], &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># move the pointers according to the specific rules of the pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">pointer1&lt;/span>, &lt;span style="color:#000">pointer2&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">move_pointers&lt;/span>(&lt;span style="color:#000">pointer1&lt;/span>, &lt;span style="color:#000">pointer2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to define the move_pointers() and update_result() functions. The move_pointers() function should take in the current values of the pointers, and return updated values for the pointers according to the specific rules of the pattern. The update_result() function should take in the current sub-array/sub-string and the current result, and return an updated result.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the two pointers pattern:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/two-sum/">Two Sum&lt;/a>: This problem involves finding two numbers in an array that add up to a given target number. The two pointers pattern can be used to efficiently search for these numbers by moving the pointers in opposite directions.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array&lt;/a>: This problem involves removing duplicate elements from a sorted array. The two pointers pattern can be used to efficiently remove the duplicates by comparing the elements at each pointer and moving them as necessary.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water&lt;/a>: This problem involves finding the maximum area of a container formed by two lines on a graph. The two pointers pattern can be used to efficiently search for the maximum area by moving the pointers in opposite directions.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water&lt;/a>: This problem involves finding the amount of rainwater that can be trapped between bars on a histogram. The two pointers pattern can be used to efficiently calculate the trapped water by moving the pointers inwards from the ends of the array.&lt;/li>
&lt;/ul>
&lt;h2 id="3-fast-and-slow-pointers">3. Fast and slow pointers&lt;/h2>
&lt;p>The fast and slow pointers pattern is a common technique used to solve problems involving linked lists. It involves using two pointers that traverse the linked list at different speeds. The &amp;ldquo;slow&amp;rdquo; pointer moves one step at a time, while the &amp;ldquo;fast&amp;rdquo; pointer moves two steps at a time. This allows the fast pointer to &amp;ldquo;lap&amp;rdquo; the slow pointer, and makes it possible to detect when the two pointers are pointing to the same node (i.e., they have &amp;ldquo;collided&amp;rdquo;).&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the pointers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">slow_pointer&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">linked_list&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">fast_pointer&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">linked_list&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until the pointers reach the end of the linked list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">fast_pointer&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span> &lt;span style="color:#000">and&lt;/span> &lt;span style="color:#000">fast_pointer&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">next&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current nodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">slow_pointer&lt;/span>, &lt;span style="color:#000">fast_pointer&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># move the pointers according to the specific rules of the pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">slow_pointer&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">slow_pointer&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">fast_pointer&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">fast_pointer&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">next&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># check if the pointers have collided&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">slow_pointer&lt;/span> &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#000">fast_pointer&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to define the update_result() function, which should take in the current values of the slow and fast pointers, and the current result, and return an updated result. The exact details of what this function does will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the fast and slow pointers pattern:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle&lt;/a>: This problem involves detecting whether a linked list contains a cycle. The fast and slow pointers pattern can be used to efficiently detect the cycle by moving the pointers at different speeds and checking for overlap.&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/middle-of-the-linked-list/">Middle of the Linked List&lt;/a>: This problem involves finding the middle element of a linked list. The fast and slow pointers pattern can be used to efficiently find the middle element by moving the pointers at different speeds and stopping when the fast pointer reaches the end of the list.&lt;/li>
&lt;li>Happy Number: This problem involves determining whether a number is a happy number. The fast and slow pointers pattern can be used to efficiently check for happiness by moving the pointers at different speeds and checking for a cycle.
Reorder List: This problem involves reordering the elements of a linked list in a specific way. The fast and slow pointers pattern can be used to efficiently reorder the elements by moving the pointers at different speeds and rearranging the elements as necessary.&lt;/li>
&lt;li>Palindrome Linked List: This problem involves checking whether a linked list is a palindrome. The fast and slow pointers pattern can be used to efficiently check for palindromicity by moving the pointers at different speeds and comparing the elements at each pointer.&lt;/li>
&lt;/ul>
&lt;h2 id="4-merge-intervals">4. Merge Intervals&lt;/h2>
&lt;p>The merge intervals pattern is a common technique used to solve problems involving sets of intervals. It involves sorting the intervals by their start time, and then merging any intervals that overlap. This allows you to take a set of potentially overlapping intervals and convert it into a set of non-overlapping intervals.&lt;/p>
&lt;p>Here is a simple template in Python that you can use to solve any problem that uses the merge intervals pattern:&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># sort the intervals by their start time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">intervals&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">sorted&lt;/span>(&lt;span style="color:#000">intervals&lt;/span>, &lt;span style="color:#000">key&lt;/span>&lt;span style="color:#000">=&lt;/span>&lt;span style="color:#a90d91">lambda&lt;/span> &lt;span style="color:#000">x&lt;/span>: &lt;span style="color:#000">x&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the result list with the first interval&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> [&lt;span style="color:#000">intervals&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop through the remaining intervals&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#a90d91">range&lt;/span>(&lt;span style="color:#1c01ce">1&lt;/span>, &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">intervals&lt;/span>)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># get the last interval in the result list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">last_interval&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">result&lt;/span>[&lt;span style="color:#000">-&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># check if the current interval overlaps with the last interval&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">intervals&lt;/span>[&lt;span style="color:#000">i&lt;/span>][&lt;span style="color:#1c01ce">0&lt;/span>] &lt;span style="color:#000">&amp;lt;=&lt;/span> &lt;span style="color:#000">last_interval&lt;/span>[&lt;span style="color:#1c01ce">1&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># if it does, merge the current interval with the last interval&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span>[&lt;span style="color:#000">-&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>] &lt;span style="color:#000">=&lt;/span> (&lt;span style="color:#000">last_interval&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>], &lt;span style="color:#a90d91">max&lt;/span>(&lt;span style="color:#000">last_interval&lt;/span>[&lt;span style="color:#1c01ce">1&lt;/span>], &lt;span style="color:#000">intervals&lt;/span>[&lt;span style="color:#000">i&lt;/span>][&lt;span style="color:#1c01ce">1&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># if it doesn&amp;#39;t, add the current interval to the result list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">intervals&lt;/span>[&lt;span style="color:#000">i&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to provide a list of intervals (in the form of tuples of start and end times), and the template will return a list of non-overlapping intervals. The exact details of how the intervals are represented will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the merge intervals pattern:&lt;/p>
&lt;ul>
&lt;li>Merge Intervals: This problem involves merging a list of intervals that may overlap. The merge intervals pattern can be used to efficiently combine the overlapping intervals into a single interval.&lt;/li>
&lt;li>Insert Interval: This problem involves inserting a new interval into a list of intervals that may overlap. The merge intervals pattern can be used to efficiently combine the overlapping intervals and insert the new interval into the resulting list.&lt;/li>
&lt;li>Meeting Rooms: This problem involves checking whether it is possible to attend all of the meetings in a list of intervals. The merge intervals pattern can be used to efficiently combine the overlapping intervals and check whether any conflicts exist.&lt;/li>
&lt;li>Meeting Rooms II: This problem involves finding the minimum number of rooms needed to hold all of the meetings in a list of intervals. The merge intervals pattern can be used to efficiently combine the overlapping intervals and calculate the minimum number of rooms required.&lt;/li>
&lt;li>Minimum Number of Arrows to Burst Balloons: This problem involves finding the minimum number of arrows needed to burst a given set of balloons. The merge intervals pattern can be used to efficiently combine the overlapping intervals representing the balloons and calculate the minimum number of arrows required&lt;/li>
&lt;/ul>
&lt;h2 id="5-cyclic-sort">5. Cyclic sort&lt;/h2>
&lt;p>Cyclic sort is a technique used to sort a list of numbers that are in a certain range, but not necessarily in the correct order. It involves looping through the list and &amp;ldquo;cycling&amp;rdquo; the numbers into the correct positions. For example, if the list is [3, 1, 5, 4, 2] and the range is 1 to 5, the first step would be to put the 1 in its correct position at index 0, the second step would be to put the 2 in its correct position at index 1, and so on.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the current index and the number of items to sort&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">current_index&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">num_to_sort&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">arr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until all items have been sorted&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">num_to_sort&lt;/span> &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># get the correct value for the current index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">correct_value&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">current_index&lt;/span> &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># check if the current value is already correct&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">current_index&lt;/span>] &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#000">correct_value&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># if it is, move on to the next index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">current_index&lt;/span> &lt;span style="color:#000">+=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">num_to_sort&lt;/span> &lt;span style="color:#000">-=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># if it isn&amp;#39;t, swap the current value with the correct value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">current_index&lt;/span>], &lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">current_index&lt;/span>] &lt;span style="color:#000">-&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>] &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">current_index&lt;/span>] &lt;span style="color:#000">-&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>], &lt;span style="color:#000">arr&lt;/span>[&lt;span style="color:#000">current_index&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the sorted array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">arr&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to provide a list of numbers that are in a certain range, and the template will return the sorted list. The exact details of how the list is represented and the range of numbers will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the cyclic sort pattern:&lt;/p>
&lt;ul>
&lt;li>Find the Duplicate Number: This problem involves finding the duplicate element in an array of numbers that are in the range 1 to n.&lt;/li>
&lt;li>Find the Missing Number: This problem involves finding the missing element in an array of numbers that are in the range 1 to n.&lt;/li>
&lt;li>Find the Smallest Missing Positive Number: This problem involves finding the smallest missing positive number in an array of numbers.&lt;/li>
&lt;li>Find All Duplicates in an Array: This problem involves finding all of the duplicate elements in an array of numbers.&lt;/li>
&lt;li>Find the Rank of a Number: This problem involves finding the rank of a given number in an array of numbers that are in a cyclic order.&lt;/li>
&lt;/ul>
&lt;h2 id="6-in-place-reversal-of-linked-list">6. In-place reversal of linked-list&lt;/h2>
&lt;p>&amp;ldquo;In-place reversal of a linked list&amp;rdquo; refers to a technique for reversing the order of the nodes in a linked list without using any additional data structures. This is done by changing the links between the nodes in the linked list so that the nodes are connected in the opposite order.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the previous, current, and next nodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">prev_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">curr_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">linked_list&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">next_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until the current node is None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">curr_node&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># store the next node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">next_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">curr_node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># reverse the link between the current and previous nodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">curr_node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">next&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">prev_node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># move the previous and current nodes forward&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">prev_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">curr_node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">curr_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">next_node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># set the head of the linked list to the new start node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">linked_list&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">head&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">prev_node&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to provide a linked list object and the template will reverse the order of the nodes in the linked list. The exact details of how the linked list is represented will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the in-place reversal of linked list pattern:&lt;/p>
&lt;ul>
&lt;li>Reverse Linked List: This problem involves reversing the order of elements in a linked list.&lt;/li>
&lt;li>Reverse Linked List II: This problem involves reversing a portion of a linked list.&lt;/li>
&lt;li>Palindrome Linked List: This problem involves checking whether a linked list is a palindrome.&lt;/li>
&lt;li>Reorder List: This problem involves reordering the elements of a linked list in a specific way.&lt;/li>
&lt;li>Swap Nodes in Pairs: This problem involves swapping the nodes in a linked list in pairs.&lt;/li>
&lt;/ul>
&lt;h2 id="7-tree-bfs">7. Tree BFS&lt;/h2>
&lt;p>The tree BFS (Breadth-First Search) pattern is a technique used to traverse the nodes of a tree in a level-by-level order. In the case of a binary tree (i.e., a tree in which each node has at most two children), the tree BFS algorithm can be implemented as follows:&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the queue with the root node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">queue&lt;/span> &lt;span style="color:#000">=&lt;/span> [&lt;span style="color:#000">root&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until the queue is empty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">queue&lt;/span>) &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># get the next node from the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">current_node&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">queue&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">pop&lt;/span>(&lt;span style="color:#1c01ce">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">current_node&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># add the left and right child nodes of the current node to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">current_node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">left&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">queue&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">current_node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">left&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">current_node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">right&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">queue&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">current_node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to provide the root node of the binary tree and define the update_result() function, which should take in the current node and the current result, and return an updated result. The exact details of what this function does will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the tree BFS pattern:&lt;/p>
&lt;ul>
&lt;li>Binary Tree Level Order Traversal: This problem involves performing a level-order traversal of a binary tree.&lt;/li>
&lt;li>Minimum Depth of Binary Tree: This problem involves finding the minimum depth of a binary tree.&lt;/li>
&lt;li>Symmetric Tree: This problem involves checking whether a binary tree is symmetric.&lt;/li>
&lt;li>Binary Tree Zigzag Level Order Traversal: This problem involves performing a zigzag-level-order traversal of a binary tree.&lt;/li>
&lt;li>Serialize and Deserialize Binary Tree: This problem involves serializing and deserializing a binary tree.&lt;/li>
&lt;/ul>
&lt;h2 id="8-tree-dfs">8. Tree DFS&lt;/h2>
&lt;p>The tree DFS (Depth-First Search) pattern is a technique used to traverse the nodes of a tree in a depth-first manner. In the case of a binary tree (i.e., a tree in which each node has at most two children), the tree DFS algorithm can be implemented as follows:&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># perform the DFS traversal on the root node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">traverse&lt;/span>(&lt;span style="color:#000">root&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">traverse&lt;/span>(&lt;span style="color:#000">node&lt;/span>, &lt;span style="color:#000">result&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">node&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># recursively traverse the left and right child nodes of the current node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">left&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">traverse&lt;/span>(&lt;span style="color:#000">node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">left&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">right&lt;/span> &lt;span style="color:#000">is&lt;/span> &lt;span style="color:#000">not&lt;/span> &lt;span style="color:#a90d91">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">traverse&lt;/span>(&lt;span style="color:#000">node&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">right&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to provide the root node of the binary tree and define the update_result() function, which should take in the current node and the current result, and return an updated result. The exact details of what this function does will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the tree DFS pattern:&lt;/p>
&lt;ul>
&lt;li>Binary Tree Preorder Traversal: This problem involves performing a preorder traversal of a binary tree.&lt;/li>
&lt;li>Binary Tree Inorder Traversal: This problem involves performing an inorder traversal of a binary tree.&lt;/li>
&lt;li>Binary Tree Postorder Traversal: This problem involves performing a postorder traversal of a binary tree.&lt;/li>
&lt;li>Validate Binary Search Tree: This problem involves checking whether a binary tree is a valid binary search tree.&lt;/li>
&lt;li>Maximum Depth of Binary Tree: This problem involves finding the maximum depth of a binary tree.&lt;/li>
&lt;/ul>
&lt;h2 id="9-two-heaps">9. Two heaps&lt;/h2>
&lt;p>The &amp;ldquo;two heaps&amp;rdquo; pattern is a common technique used to solve problems involving sets of numbers. It involves using two heaps (i.e., data structures that provide efficient ways to insert and remove items, and to find the minimum or maximum item) to store the numbers in the set. This allows you to efficiently maintain certain properties of the numbers in the set, and to quickly perform operations on the numbers when needed.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">import&lt;/span> &lt;span style="color:#000">heapq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the two heaps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">heap1&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">heap2&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop through the numbers in the set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">num&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">nums&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># insert the number into the appropriate heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">condition1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappush&lt;/span>(&lt;span style="color:#000">heap1&lt;/span>, &lt;span style="color:#000">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappush&lt;/span>(&lt;span style="color:#000">heap2&lt;/span>, &lt;span style="color:#000">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># balance the heaps if necessary&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">condition2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappush&lt;/span>(&lt;span style="color:#000">heap2&lt;/span>, &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappop&lt;/span>(&lt;span style="color:#000">heap1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">elif&lt;/span> &lt;span style="color:#000">condition3&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappush&lt;/span>(&lt;span style="color:#000">heap1&lt;/span>, &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappop&lt;/span>(&lt;span style="color:#000">heap2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># update any other variables you need&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">update_variables&lt;/span>(&lt;span style="color:#000">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To use this template, you just need to provide a list of numbers and define the condition1, condition2, condition3, and update_variables() functions. These functions should determine which heap to insert the current number into, whether the heaps need to be balanced, and how to update any other variables you need. The exact details of what these functions do will depend on the specific problem you&amp;rsquo;re trying to solve.&lt;/p>
&lt;p>For example, if you want to use the two heaps pattern to find the median of a set of numbers, you could define the following functions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># insert the number into the smaller_half heap if it is smaller than the current median,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># or into the larger_half heap if it is larger or equal to the current median&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">condition1&lt;/span>(&lt;span style="color:#000">num&lt;/span>, &lt;span style="color:#000">median&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">num&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span> &lt;span style="color:#000">median&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># balance the heaps if the size difference between them is greater than 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">condition2&lt;/span>(&lt;span style="color:#000">smaller_half&lt;/span>, &lt;span style="color:#000">larger_half&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">smaller_half&lt;/span>) &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">larger_half&lt;/span>) &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># balance the heaps if the size difference between them is greater than 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">condition3&lt;/span>(&lt;span style="color:#000">smaller_half&lt;/span>, &lt;span style="color:#000">larger_half&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">larger_half&lt;/span>) &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">smaller_half&lt;/span>) &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># update the median if the size of the two heaps is equal, or if one heap is larger than the other&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">update_variables&lt;/span>(&lt;span style="color:#000">num&lt;/span>, &lt;span style="color:#000">median&lt;/span>, &lt;span style="color:#000">smaller_half&lt;/span>, &lt;span style="color:#000">larger_half&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">smaller_half&lt;/span>) &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">larger_half&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">median&lt;/span> &lt;span style="color:#000">=&lt;/span> (&lt;span style="color:#000">-&lt;/span>&lt;span style="color:#000">smaller_half&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>] &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#000">larger_half&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>]) &lt;span style="color:#000">/&lt;/span> &lt;span style="color:#1c01ce">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">elif&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">smaller_half&lt;/span>) &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">larger_half&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">median&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">-&lt;/span>&lt;span style="color:#000">smaller_half&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">median&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">larger_half&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the two heaps pattern:&lt;/p>
&lt;ul>
&lt;li>Kth Largest Element in an Array: This problem involves finding the kth largest element in an array.&lt;/li>
&lt;li>Median of Two Sorted Arrays: This problem involves finding the median of two sorted arrays.&lt;/li>
&lt;li>Sliding Window Median: This problem involves finding the median of the elements in a sliding window of an array.&lt;/li>
&lt;li>Top K Frequent Elements: This problem involves finding the k most frequent elements in an array.&lt;/li>
&lt;li>Kth Smallest Element in a Sorted Matrix: This problem involves finding the kth smallest element in a sorted matrix.&lt;/li>
&lt;/ul>
&lt;h2 id="10-subsets">10. Subsets&lt;/h2>
&lt;p>The &amp;ldquo;subsets&amp;rdquo; pattern is a common technique used to solve problems involving sets of numbers. It involves generating all possible subsets of the set and then performing some operation on each subset to find the desired result. This allows you to consider all possible combinations of numbers in the set and to efficiently compute the result for each combination.&lt;/p>
&lt;p>&lt;strong>Template 1&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># generate all possible subsets of the set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">subset&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">itertools&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">combinations&lt;/span>(&lt;span style="color:#000">nums&lt;/span>, &lt;span style="color:#000">r&lt;/span>) &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">r&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#a90d91">range&lt;/span>(&lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">nums&lt;/span>)&lt;span style="color:#000">+&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current subset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">subset&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Template 2&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># generate all possible subsets of the set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#a90d91">range&lt;/span>(&lt;span style="color:#1c01ce">1&lt;/span>, &lt;span style="color:#1c01ce">2&lt;/span>&lt;span style="color:#000">**&lt;/span>&lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">nums&lt;/span>)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># convert the binary representation of i to a list of indices&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">indices&lt;/span> &lt;span style="color:#000">=&lt;/span> [&lt;span style="color:#000">j&lt;/span> &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">j&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#a90d91">range&lt;/span>(&lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">nums&lt;/span>)) &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000">&amp;amp;&lt;/span> (&lt;span style="color:#1c01ce">1&lt;/span> &lt;span style="color:#000">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#000">j&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># generate the current subset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">subset&lt;/span> &lt;span style="color:#000">=&lt;/span> [&lt;span style="color:#000">nums&lt;/span>[&lt;span style="color:#000">j&lt;/span>] &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">j&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">indices&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># perform the operation on the current subset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">update_result&lt;/span>(&lt;span style="color:#000">subset&lt;/span>, &lt;span style="color:#000">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It uses a single loop and binary operations to generate the subsets. It converts the binary representation of each number in the range 1..2^len(nums) to a list of indices, and then uses those indices to select the elements of the set that are included in the current subset.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the subsets pattern:&lt;/p>
&lt;ul>
&lt;li>Subsets: This problem involves generating all of the subsets of a given set of elements.&lt;/li>
&lt;li>Subsets II: This problem involves generating all of the subsets of a given set of elements, allowing for duplicates.&lt;/li>
&lt;li>Permutations: This problem involves generating all of the permutations of a given set of elements.&lt;/li>
&lt;li>Permutations II: This problem involves generating all of the permutations of a given set of elements, allowing for duplicates.&lt;/li>
&lt;li>Combination Sum: This problem involves finding all of the combinations of a given set of elements that add up to a specific target sum.&lt;/li>
&lt;/ul>
&lt;h2 id="11-modified-binary-search">11. Modified Binary Search&lt;/h2>
&lt;p>The &amp;ldquo;modified binary search&amp;rdquo; pattern is a common technique used to solve problems involving a sorted array of numbers. It is similar to regular binary search, but it allows you to modify the condition used to determine whether to search the left or right half of the array. This can be useful if the problem you&amp;rsquo;re trying to solve involves finding the position of an element in the array that satisfies a certain condition, or if the array has duplicate elements and you need to find the first or last occurrence of a given element.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the left and right pointers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">left&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">right&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">nums&lt;/span>) &lt;span style="color:#000">-&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># search the array until the left and right pointers meet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">left&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span> &lt;span style="color:#000">right&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># calculate the middle index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">mid&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">left&lt;/span> &lt;span style="color:#000">+&lt;/span> (&lt;span style="color:#000">right&lt;/span> &lt;span style="color:#000">-&lt;/span> &lt;span style="color:#000">left&lt;/span>) &lt;span style="color:#000">//&lt;/span> &lt;span style="color:#1c01ce">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># modify the condition used to determine which half of the array to search&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">condition&lt;/span>(&lt;span style="color:#000">nums&lt;/span>[&lt;span style="color:#000">mid&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">right&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">mid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">left&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">mid&lt;/span> &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">left&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you want to use the modified binary search pattern to find the first occurrence of a given element in an array, you could define the following condition() function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">condition&lt;/span>(&lt;span style="color:#000">num&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">num&lt;/span> &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#000">target&lt;/span> &lt;span style="color:#000">and&lt;/span> (&lt;span style="color:#000">mid&lt;/span> &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span> &lt;span style="color:#000">or&lt;/span> &lt;span style="color:#000">nums&lt;/span>[&lt;span style="color:#000">mid&lt;/span>&lt;span style="color:#000">-&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>] &lt;span style="color:#000">!=&lt;/span> &lt;span style="color:#000">target&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This function checks whether the current element is equal to the target element and whether it is the first occurrence of that element in the array (i.e., whether the element before it is not equal to the target). If both of these conditions are satisfied, then the function returns True, indicating that the left pointer should be updated to the current index. Otherwise, it returns False, indicating that the right pointer should be updated to the current index.&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the modified binary search pattern:&lt;/p>
&lt;ul>
&lt;li>Search in Rotated Sorted Array: This problem involves searching for an element in a rotated sorted array.&lt;/li>
&lt;li>Find Minimum in Rotated Sorted Array: This problem involves finding the minimum element in a rotated sorted array.&lt;/li>
&lt;li>Search in Rotated Sorted Array II: This problem involves searching for an element in a rotated sorted array that may contain duplicates.&lt;/li>
&lt;li>Find Peak Element: This problem involves finding a peak element in an array.&lt;/li>
&lt;li>Find K Closest Elements: This problem involves finding the k closest elements to a given target in an array.&lt;/li>
&lt;/ul>
&lt;h2 id="12-top-k-elements">12. Top K elements&lt;/h2>
&lt;p>The &amp;ldquo;top k elements&amp;rdquo; pattern is a common technique used to solve problems involving a large set of numbers. It involves finding the largest or smallest k elements in the set and then performing some operation on those elements to find the desired result. This allows you to efficiently select the most important elements from the set and to compute the result using only those elements.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the heap with the first k elements of the set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">heap&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">nums&lt;/span>[:&lt;span style="color:#000">k&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># heapify the heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heapify&lt;/span>(&lt;span style="color:#000">heap&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop through the remaining elements of the set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">num&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">nums&lt;/span>[&lt;span style="color:#000">k&lt;/span>:]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># insert the current element into the heap if it is larger than the smallest element in the heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">num&lt;/span> &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#000">heap&lt;/span>[&lt;span style="color:#1c01ce">0&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappushpop&lt;/span>(&lt;span style="color:#000">heap&lt;/span>, &lt;span style="color:#000">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">operation&lt;/span>(&lt;span style="color:#000">heap&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For example, if you want to use the top k elements pattern to find the sum of the largest k elements in a set, you could define the following operation() function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">operation&lt;/span>(&lt;span style="color:#000">heap&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#a90d91">sum&lt;/span>(&lt;span style="color:#000">heap&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This function simply returns the sum of all the elements in the heap, which are the largest k elements in the set&lt;/p>
&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the top k elements pattern:&lt;/p>
&lt;ul>
&lt;li>Kth Largest Element in an Array: This problem involves finding the kth largest element in an array.&lt;/li>
&lt;li>Top K Frequent Elements: This problem involves finding the k most frequent elements in an array.&lt;/li>
&lt;li>Kth Smallest Element in a Sorted Matrix: This problem involves finding the kth smallest element in a sorted matrix.&lt;/li>
&lt;li>Sort Colors: This problem involves sorting an array of colors (represented as numbers) in place.&lt;/li>
&lt;li>Minimum Cost to Hire K Workers: This problem involves finding the minimum cost to hire k workers, given their wage and productivity.&lt;/li>
&lt;/ul>
&lt;h2 id="13-k-way-merge-using-heap">13. K-way Merge (using heap)&lt;/h2>
&lt;p>The k-way merge pattern using a heap is a common technique used to merge k sorted arrays into a single sorted array. It involves using a heap data structure to efficiently select the smallest element from the k arrays and to add it to the result. This allows you to efficiently combine the k arrays into a single sorted array and to perform further operations on that array.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># initialize the result and the heap with the first elements of the k arrays&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">heap&lt;/span> &lt;span style="color:#000">=&lt;/span> [(&lt;span style="color:#000">arrays&lt;/span>[&lt;span style="color:#000">i&lt;/span>][&lt;span style="color:#1c01ce">0&lt;/span>], &lt;span style="color:#000">i&lt;/span>) &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#a90d91">range&lt;/span>(&lt;span style="color:#000">k&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># heapify the heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heapify&lt;/span>(&lt;span style="color:#000">heap&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># loop until all the arrays have been merged&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">heap&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># get the smallest element from the heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">min_element&lt;/span>, &lt;span style="color:#000">min_index&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappop&lt;/span>(&lt;span style="color:#000">heap&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># add the smallest element to the result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">min_element&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># insert the next element from the array where the smallest element was found into the heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">min_index&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">arrays&lt;/span>[&lt;span style="color:#000">min_index&lt;/span>]) &lt;span style="color:#000">-&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">heapq&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">heappush&lt;/span>(&lt;span style="color:#000">heap&lt;/span>, (&lt;span style="color:#000">arrays&lt;/span>[&lt;span style="color:#000">min_index&lt;/span>][&lt;span style="color:#000">min_index&lt;/span>&lt;span style="color:#000">+&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span>], &lt;span style="color:#000">min_index&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># return the final result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the k-way merge (using heap) pattern:&lt;/p>
&lt;ul>
&lt;li>Merge k Sorted Lists: This problem involves merging k sorted linked lists into a single sorted linked list.&lt;/li>
&lt;li>Merge Intervals: This problem involves merging a list of intervals that may overlap.&lt;/li>
&lt;li>The Skyline Problem: This problem involves finding the skyline of a set of buildings.&lt;/li>
&lt;li>Minimum Cost to Connect Sticks: This problem involves connecting a set of sticks with minimum total cost.&lt;/li>
&lt;li>Maximum Number of Events That Can Be Attended: This problem involves finding the maximum number of events that a person can attend, given a list of events with start and end times.&lt;/li>
&lt;/ul>
&lt;h2 id="14-topological-sort">14. Topological Sort&lt;/h2>
&lt;p>Topological sort is an algorithm that is used to arrange the vertices of a directed acyclic graph (DAG) in a linear order such that, for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. This is useful for problems where a certain set of dependencies must be satisfied, such as scheduling tasks or determining the order in which to assemble a product.&lt;/p>
&lt;p>To perform a topological sort, we first identify all of the vertices with no incoming edges (i.e., no dependencies) and put them in a queue. We then remove these vertices from the graph and repeat the process until the queue is empty. At each step, we add the vertices we remove to a list, which will eventually give us the topological ordering of the vertices.&lt;/p>
&lt;p>Topological sort is commonly used to solve problems on LeetCode, such as &amp;ldquo;Course Schedule&amp;rdquo; and &amp;ldquo;Alien Dictionary&amp;rdquo;. It can also be useful for solving other problems that involve dependencies between objects or tasks.&lt;/p>
&lt;p>&lt;strong>Template&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">from&lt;/span> &lt;span style="color:#000">collections&lt;/span> &lt;span style="color:#a90d91">import&lt;/span> &lt;span style="color:#000">deque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">topological_sort&lt;/span>(&lt;span style="color:#000">vertices&lt;/span>, &lt;span style="color:#000">edges&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Create a list to store the topological ordering of the vertices&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">top_order&lt;/span> &lt;span style="color:#000">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Create a queue to keep track of the vertices with no incoming edges&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">queue&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">deque&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Create a dictionary to store the indegrees of each vertex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">indegrees&lt;/span> &lt;span style="color:#000">=&lt;/span> {&lt;span style="color:#000">vertex&lt;/span>: &lt;span style="color:#1c01ce">0&lt;/span> &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">vertex&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">vertices&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Create a dictionary to store the adjacency list for each vertex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">adj_list&lt;/span> &lt;span style="color:#000">=&lt;/span> {&lt;span style="color:#000">vertex&lt;/span>: [] &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">vertex&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">vertices&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Populate the indegrees dictionary and adjacency list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">edge&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">edges&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">u&lt;/span>, &lt;span style="color:#000">v&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">edge&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">indegrees&lt;/span>[&lt;span style="color:#000">v&lt;/span>] &lt;span style="color:#000">+=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">adj_list&lt;/span>[&lt;span style="color:#000">u&lt;/span>]&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Add all vertices with no incoming edges to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">vertex&lt;/span>, &lt;span style="color:#000">indegree&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">indegrees&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">items&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">indegree&lt;/span> &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">queue&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">vertex&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Perform the topological sort&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">while&lt;/span> &lt;span style="color:#000">queue&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Remove a vertex from the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">vertex&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">queue&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">popleft&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Add the vertex to the topological ordering&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">top_order&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">vertex&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># Decrement the indegree of each of its neighbors&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">neighbor&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">adj_list&lt;/span>[&lt;span style="color:#000">vertex&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">indegrees&lt;/span>[&lt;span style="color:#000">neighbor&lt;/span>] &lt;span style="color:#000">-=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># If the indegree of a neighbor becomes 0, add it to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">indegrees&lt;/span>[&lt;span style="color:#000">neighbor&lt;/span>] &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">queue&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">append&lt;/span>(&lt;span style="color:#000">neighbor&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># If there are any vertices left in the graph, then the original graph was not a DAG&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">top_order&lt;/span>) &lt;span style="color:#000">!=&lt;/span> &lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">vertices&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">top_order&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Practise&lt;/strong>&lt;/p>
&lt;p>Here are some important problems on leetcode that can be solved using the topological sort pattern:&lt;/p>
&lt;ul>
&lt;li>Course Schedule: This problem involves checking whether a given set of courses can be completed, given the dependencies between the courses.&lt;/li>
&lt;li>Course Schedule II: This problem involves finding the order in which the courses should be taken in order to complete them all.&lt;/li>
&lt;li>Alien Dictionary: This problem involves reconstructing the order of the letters in an alien language, given a list of words.&lt;/li>
&lt;li>Sequence Reconstruction: This problem involves checking whether a given sequence can be reconstructed from a given set of subsequences.&lt;/li>
&lt;li>Minimum Height Trees: This problem involves finding the root(s) of a tree with minimum height.&lt;/li>
&lt;/ul>
&lt;h1 id="references">References&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://designgurus.org/link/pvL2Ws?url=https%3A%2F%2Fdesigngurus.org%2Fcourse%3Fcourseid%3Dgrokking-the-coding-interview">Grokking the Coding Interview: Patterns for Coding Questions&lt;/a>&lt;/p>
&lt;p>This is structured course for understanding every pattern step by step using visual walk-through.&lt;/p>
&lt;p>&lt;em>&lt;strong>Disclaimer&lt;/strong>: It&amp;rsquo;s an affiliate link. If you would like to thank me for this post, please purchase via that link. If you do not want to use that link for some reason, &lt;a href="https://designgurus.org/course/grokking-the-coding-interview">here&lt;/a> is a clean link.&lt;/em> :)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed">14 patterns to ace any coding interview question&lt;/a>&lt;/p>
&lt;p>This blog post is a fork of this post. I would recommend checking it out.
It&amp;rsquo;s an overview of the &lt;a href="https://designgurus.org/link/pvL2Ws?url=https%3A%2F%2Fdesigngurus.org%2Fcourse%3Fcourseid%3Dgrokking-the-coding-interview">Grokking course&lt;/a> shared above.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://emre.me/categories/#coding-patterns">emre.me #coding patterns&lt;/a>&lt;/p>
&lt;p>Excellent post about how to identify the patterns. Highly recommended.&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>