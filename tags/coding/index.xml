<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>coding on Saikat Kumar Dey</title><link>https://saikatkumardey.com/tags/coding/</link><description>coding</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 05 Sep 2021 09:59:45 +0530</lastBuildDate><atom:link href="https://saikatkumardey.com/tags/coding/index.xml" rel="self" type="application/rss+xml"/><item><title>A Simplified Implementation of Quicksort</title><link>https://saikatkumardey.com/essays/a-simplified-implementation-of-quicksort/</link><pubDate>Sun, 05 Sep 2021 09:59:45 +0530</pubDate><guid>https://saikatkumardey.com/essays/a-simplified-implementation-of-quicksort/</guid><description>&lt;p>Quicksort is a beautiful algorithm. It&amp;rsquo;s considered the fastest sorting algorithm in practice. Most implementations I&amp;rsquo;ve seen online are complicated. This post will demonstrate a simple implementation that trades space complexity for readability.&lt;/p>
&lt;h2 id="how-does-quicksort-work">How does quicksort work?&lt;/h2>
&lt;p>3 steps.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Choose&lt;/strong> a pivot element.&lt;/li>
&lt;li>&lt;strong>Partition&lt;/strong>: Put all elements smaller than the pivot in a smaller array, (say, smaller_subarray). Put all elements greater than the pivot in another array (say, greater_subarray).&lt;/li>
&lt;li>&lt;strong>Recurse &amp;amp; Merge&lt;/strong>: Recursively sort the smaller and greater sub-arrays. Merge the sorted arrays with the pivot.&lt;/li>
&lt;/ol>
&lt;h2 id="how-do-we-implement-it-in-python">How do we implement it in Python?&lt;/h2>
&lt;p>Let&amp;rsquo;s start with the high-level function &lt;code>quicksort()&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">def&lt;/span> &lt;span style="color:#268bd2">quicksort&lt;/span>(array: List[&lt;span style="color:#b58900">int&lt;/span>]) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> List[&lt;span style="color:#b58900">int&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&amp;#34;Recursive implementation of quicksort.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> array (List[int]): a list of integers
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> List[int]: sorted array
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75"># Base case&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(array) &lt;span style="color:#719e07">&amp;lt;=&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> array
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75"># Step 1: choose a pivot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pivot_idx &lt;span style="color:#719e07">=&lt;/span> random&lt;span style="color:#719e07">.&lt;/span>choice(&lt;span style="color:#b58900">range&lt;/span>(&lt;span style="color:#b58900">len&lt;/span>(array)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75"># Step 2: partition&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smaller_subarray, greater_subarray &lt;span style="color:#719e07">=&lt;/span> partition(array, pivot_idx)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75"># Step 3: Recurse on smaller and greater subarrays.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quicksort(smaller_subarray)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> [array[pivot_idx]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> quicksort(greater_subarray)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s go line by line,&lt;/p>
&lt;h3 id="base-case">Base case&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(array) &lt;span style="color:#719e07">&amp;lt;=&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> array
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Every recursive function must have one. If we have an empty or single-item array, there&amp;rsquo;s nothing to sort. We simply return the array.&lt;/p>
&lt;h3 id="step-1-choose-a-pivot">Step 1: Choose a pivot&lt;/h3>
&lt;p>&lt;code> pivot_idx = random.choice(range(len(array)))&lt;/code>&lt;/p>
&lt;p>The choice of pivot is the difference between having an &lt;code>O(N log N)&lt;/code> vs &lt;code>O(N^2)&lt;/code> time complexity.&lt;/p>
&lt;p>How so? Let&amp;rsquo;s take an example.&lt;/p>
&lt;p>The worst-case involves having an already sorted array.&lt;/p>
&lt;p>&lt;code>array = [1,2,3,4,5]&lt;/code>&lt;/p>
&lt;p>The image below shows recursion trees using two different pivot selection strategies:&lt;/p>
&lt;p>&lt;strong>Legend&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Blue lines =&amp;gt; the greater subarray.&lt;/li>
&lt;li>Orange lines =&amp;gt; the smaller subarray.&lt;/li>
&lt;li>Red lines =&amp;gt; the pivot.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1630829735302/4wvnJNbu8.png" alt="Screenshot 2021-09-05 at 1.45.23 PM.png">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Left shows the case where we always choose the first/last item as the pivot. This leads to higher recursion depth as the subproblem size reduces by 1 at each level. We have roughly &lt;code>O(N)&lt;/code> levels / recursive calls. Since joining the sub-arrays with the pivot is &lt;code>O(N)&lt;/code>, this leads to &lt;code>O(N^2)&lt;/code> time complexity.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Right shows the ideal case where we choose the median as the pivot at every level. This leads to balanced sub-problems. The recursion depth is lower, roughly &lt;code>O(log N)&lt;/code>. This leads to &lt;code>O(N log N)&lt;/code> time complexity.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://www.cs.cmu.edu/afs/cs/academic/class/15451-s07/www/lecture_notes/lect0123.pdf">Choosing a random pivot leads to an &lt;em>expected&lt;/em> runtime of &lt;code>O(N log N)&lt;/code> time complexity&lt;/a>. We use that in this implementation.&lt;/p>
&lt;p>Wait! There&amp;rsquo;s still one case where &lt;code>quicksort()&lt;/code> could be &lt;code>O(N^2)&lt;/code>, even after choosing a randomized/median pivot. This is the case when every item in the array is identical. We could add a check to avoid this case as well.&lt;/p>
&lt;p>According to this &lt;a href="https://algs4.cs.princeton.edu/23quicksort/">source&lt;/a> ,&lt;/p>
&lt;blockquote>
&lt;p>The probability that quicksort will use a quadratic number of compares when sorting a large array on your computer is much less than the probability that your computer will be struck by lightning!&lt;/p>
&lt;/blockquote>
&lt;h3 id="step-2-partition">Step 2: Partition&lt;/h3>
&lt;p>We write the high-level function assuming that we have a magic function &lt;code>partition()&lt;/code> which returns two arrays.&lt;/p>
&lt;ul>
&lt;li>&lt;code>smaller_subarray&lt;/code>: all elements &lt;code>&amp;lt;=&lt;/code> the pivot&lt;/li>
&lt;li>&lt;code>greater_subarray&lt;/code>: all elements &lt;code>&amp;gt;&lt;/code> the pivot&lt;/li>
&lt;/ul>
&lt;p>The implementation of &lt;code>partition()&lt;/code> is quite simple. We compare each item in the array with the pivot. If it&amp;rsquo;s &lt;code>&amp;lt;=&lt;/code> pivot, we add it to the smaller sub-array, else we add it to the greater sub-array.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">def&lt;/span> &lt;span style="color:#268bd2">partition&lt;/span>(array: List[&lt;span style="color:#b58900">int&lt;/span>], pivot_idx: &lt;span style="color:#b58900">int&lt;/span>) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> Tuple[List[&lt;span style="color:#b58900">int&lt;/span>], List[&lt;span style="color:#b58900">int&lt;/span>]]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&amp;#34;Parition array into subarrays smaller and greater than the pivot.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> array (List[int]): input array
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> pivot_idx (int): index of the pivot
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> Tuple[List[int], List[int]]: smaller subarray, greater subarray
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2aa198"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smaller_subarray, greater_subarray &lt;span style="color:#719e07">=&lt;/span> [], []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> idx, item &lt;span style="color:#719e07">in&lt;/span> &lt;span style="color:#b58900">enumerate&lt;/span>(array):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75"># we don&amp;#39;t want to add pivot to any of the sub-arrays&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> idx &lt;span style="color:#719e07">==&lt;/span> pivot_idx:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> item &lt;span style="color:#719e07">&amp;lt;=&lt;/span> array[pivot_idx]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smaller_subarray&lt;span style="color:#719e07">.&lt;/span>append(item)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greater_subarray&lt;span style="color:#719e07">.&lt;/span>append(item)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> smaller_subarray, greater_subarray
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="step-3">Step 3:&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">return&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quicksort(smaller_subarray)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> [array[pivot_idx]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> quicksort(greater_subarray)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This step is quite exquisite. We recurse on the smaller and greater sub-arrays and place the pivot in between them. The beauty of a recursive implementation is that we could re-use our function with a smaller size of the input and trust that it would work.&lt;/p>
&lt;p>Let&amp;rsquo;s unroll it a bit.&lt;/p>
&lt;ul>
&lt;li>&lt;code>quicksort(smaller_subarray)&lt;/code> =&amp;gt; returns a sorted version of the &lt;code>smaller_subarray&lt;/code>&lt;/li>
&lt;li>&lt;code>[array[pivot_idx]]&lt;/code> =&amp;gt; out pivot in a list. It&amp;rsquo;s needed for concatenating it with the other two lists.&lt;/li>
&lt;li>&lt;code>quicksort(greater_subarray)&lt;/code> =&amp;gt; returns a sorted version of the &lt;code>greater_subarray&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Now, we join the 3 lists including the pivot, and return the final sorted list.&lt;/p>
&lt;h2 id="complexity">Complexity&lt;/h2>
&lt;h3 id="time">Time&lt;/h3>
&lt;p>&lt;strong>Expected&lt;/strong> run-time of &lt;code>O(N log N)&lt;/code> since it&amp;rsquo;s a randomized implementation.&lt;/p>
&lt;p>We do &lt;code>O(N)&lt;/code> work at each &lt;code>quicksort()&lt;/code> call. The major components are &lt;code>partition()&lt;/code> and merge step - both are &lt;code>O(N)&lt;/code>.&lt;/p>
&lt;p>For randomized implementation, we have O(log N) levels/recursive calls.&lt;/p>
&lt;p>So, expected time complexity ~ &lt;code>Number of recursive calls&lt;/code> * &lt;code>work done per recursive call&lt;/code> ~ &lt;code>O(N) * O(log N)&lt;/code> ~ &lt;code>O(N log N)&lt;/code>&lt;/p>
&lt;h3 id="space">Space&lt;/h3>
&lt;p>&lt;code>O(N)&lt;/code> since we use extra space for storing the smaller and greater sub-arrays. The recursion stack also uses &lt;code>O(log N)&lt;/code> space. Overall, this implementation uses &lt;code>O(N)&lt;/code> space.&lt;/p>
&lt;p>The in-place implementation without using auxiliary lists would lead to an &lt;code>O(log N)&lt;/code> space complexity.&lt;/p>
&lt;h2 id="the-code">The code&lt;/h2>
&lt;p>The implementation including the &lt;code>partition()&lt;/code> and tests are here.&lt;/p>
&lt;p>%[https://gist.github.com/saikatkumardey/5c0eb3ed8d187046ed7d46ff4dab8fe1]&lt;/p></description></item></channel></rss>